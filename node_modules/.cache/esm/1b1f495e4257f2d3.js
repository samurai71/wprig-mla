/* eslint-env es6 */
'use strict';;let importFresh,log,colors,rimraf,mkdirp,fs,pipeline,gulpPlugins,nameFieldDefaults,prodThemePath,isProd,rootPath;_425‍.x([["getDefaultConfig",()=>getDefaultConfig],["getThemeConfig",()=>getThemeConfig],["getStringReplacementTasks",()=>getStringReplacementTasks],["logError",()=>logError],["createProdDir",()=>createProdDir],["gulpRelativeDest",()=>gulpRelativeDest],["backslashToForwardSlash",()=>backslashToForwardSlash],["configValueDefined",()=>configValueDefined],["appendBaseToFilePathArray",()=>appendBaseToFilePathArray]]);_425‍.w("import-fresh",[["default",["importFresh"],function(v){importFresh=v}]]);_425‍.w("fancy-log",[["default",["log"],function(v){log=v}]]);_425‍.w("ansi-colors",[["default",["colors"],function(v){colors=v}]]);_425‍.w("rimraf",[["default",["rimraf"],function(v){rimraf=v}]]);_425‍.w("mkdirp",[["default",["mkdirp"],function(v){mkdirp=v}]]);_425‍.w("fs",[["default",["fs"],function(v){fs=v}]]);_425‍.w("mississippi",[["pipeline",["pipeline"],function(v){pipeline=v}]]);_425‍.w("./constants",[["gulpPlugins",["gulpPlugins"],function(v){gulpPlugins=v}],["nameFieldDefaults",["nameFieldDefaults"],function(v){nameFieldDefaults=v}],["prodThemePath",["prodThemePath"],function(v){prodThemePath=v}],["isProd",["isProd"],function(v){isProd=v}],["rootPath",["rootPath"],function(v){rootPath=v}]]);

/**
 * External dependencies
 */








/**
 * Internal dependencies
 */








       const getDefaultConfig = () => require( `${ _425‍.a("rootPath",rootPath) }/config/config.default.json` );;_425‍.j(["getDefaultConfig"]);

/**
 * Get theme configuration.
 *
 * @param {boolean} uncached Whether to get an uncached version of the configuration. Defaults to false.
 * @return {Object} Theme configuration data.
 */
       function getThemeConfig( uncached = false ) {
	let config;
	const configPath = `${ process.cwd() }/config/themeConfig.js`;

	if ( uncached ) {
		config = _425‍.a("importFresh",importFresh)( configPath );
	} else {
		config = require( configPath );
	}

	if ( ! config.theme.slug ) {
		config.theme.slug = config.theme.name.toLowerCase().replace( /[\s_]+/g, '-' ).replace( /[^a-z0-9-]+/g, '' );
	}

	if ( ! config.theme.underscoreCase ) {
		config.theme.underscoreCase = config.theme.slug.replace( /-/g, '_' );
	}

	if ( ! config.theme.constant ) {
		config.theme.constant = config.theme.underscoreCase.toUpperCase();
	}

	if ( ! config.theme.camelCase ) {
		config.theme.camelCase = config.theme.slug
			.split( '-' )
			.map( ( part ) => part[ 0 ].toUpperCase() + part.substring( 1 ) )
			.join( '' );
	}

	if ( ! config.theme.camelCaseVar ) {
		config.theme.camelCaseVar = config.theme.camelCase[ 0 ].toLowerCase() + config.theme.camelCase.substring( 1 );
	}

	return config;
}

/**
 * Get string replacement streams to push into a pump process.
 *
 * @return {Array} List of tasks.
 */
       function getStringReplacementTasks() {
	// Get a copy of the config
	const config = getThemeConfig( _425‍.a("isProd",isProd) );

	const stringReplacementTasks = Object.keys( _425‍.a("nameFieldDefaults",nameFieldDefaults) ).map( ( nameField ) => {
		return _425‍.a("gulpPlugins",gulpPlugins).stringReplace(
			// Backslashes must be double escaped for regex
			_425‍.a("nameFieldDefaults",nameFieldDefaults)[ nameField ].replace( /\\/g, '\\\\' ),
			config.theme[ nameField ],
			{
				logs: {
					enabled: false,
				},
				searchValue: 'regex',
			}
		);
	} );

	// Return a single stream containing all the
	// string replacement tasks
	return _425‍.a("pipeline",pipeline).obj( stringReplacementTasks );
}

       function logError( errorTitle = 'gulp' ) {
	return _425‍.a("gulpPlugins",gulpPlugins).plumber( {
		errorHandler: _425‍.a("gulpPlugins",gulpPlugins).notify.onError( {
			title: errorTitle,
			message: '<%= error.message %>',
		} ),
	} );
}

       function createProdDir() {
	_425‍.a("log",log)( _425‍.a("colors",colors).green( `Creating the production theme directory ${ _425‍.a("prodThemePath",prodThemePath) }` ) );
	// Check if the prod theme directory exists
	if ( _425‍.a("fs",fs).existsSync( _425‍.a("prodThemePath",prodThemePath) ) ) {
		// and remove it
		_425‍.a("rimraf",rimraf).sync( _425‍.a("prodThemePath",prodThemePath) );
	}

	// Create the prod theme directory
	_425‍.a("mkdirp",mkdirp)( _425‍.a("prodThemePath",prodThemePath) );
}

       function gulpRelativeDest( file ) {
	const relativeProdFilePath = file.base.replace( file.cwd, _425‍.a("prodThemePath",prodThemePath) );
	return relativeProdFilePath;
}

       function backslashToForwardSlash( path ) {
	const replaceFn = ( ( p ) => p.replace( /\\/g, '/' ) );
	if ( Array.isArray( path ) ) {
		const paths = [];
		path.forEach( ( p ) => paths.push( replaceFn( p ) ) );
		return paths;
	}
	return replaceFn( path );
}

/**
 * Determine if a config value is defined
 * @param {string} configValueLocation a config value path to search for, e.g. 'config.theme.slug'
 * @return {boolean} whethere the config value is defined
 */
       function configValueDefined( configValueLocation ) {
	// We won't find anything if the location to search is empty
	if ( 0 === configValueLocation.length ) {
		return false;
	}

	// Get a copy of the config
	let config = getThemeConfig();

	// Turn the value location given into an array
	const configValueLocationArray = configValueLocation.split( '.' );

	// Remove config from the array if present
	if ( 'config' === configValueLocationArray[ 0 ] ) {
		configValueLocationArray.shift();
	}

	// Loop through the config value paths passed
	/* eslint no-unused-vars: 0 */
	for ( const currentValueLocation of configValueLocationArray ) {
		// Check if there is a match in the current object level
		if ( ! Object.prototype.hasOwnProperty.call( config, currentValueLocation ) ) {
			// Return false if no match
			return false;
		}

		// Move the config object to the next level
		config = config[ currentValueLocation ];
	}

	// If we've made it this far there is a match for the given config value path
	return true;
}

/**
 * Append a base file path to a list of files
 * @param {string|Array} filePaths the file or files to append the base path to
 * @param {string} basePath the base path to append
 * @return {string|Array} file paths with base path appended
 */
       function appendBaseToFilePathArray( filePaths, basePath ) {
	if ( ! Array.isArray( filePaths ) ) {
		return `${ basePath }/${ filePaths }`;
	}

	const output = [];

	// Loop through all file paths
	for ( const filePath of filePaths ) {
		// And push them into output with the base added
		output.push( `${ basePath }/${ filePath }` );
	}

	return output;
}
